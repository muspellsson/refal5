# For DJGPP (DOS)
OBJS_REFGO = refgo.o refaux.o bif.o load.o ri.o refio.o func1.o func2.o macros.o sysfun.o freeze.o arithm.o version.o
OBJS_REFTR = trace.o load.o rcaux.o rti.o bif.o arithm.o refaux.o func1.o func2.o macros.o lex.o dtrace.o dcom.o sysfun.o dimpl.o freeze.o rcleft.o refio.o version.o
OBJS_REFC = rc5.o parser.o lex.o sem.o pass2.o rc.o rcleft.o rcopt.o rcaux.o vyvod.o version.o

CC = gcc
CC_PATH = 

# C_FLAGS = -O2 -c -W -Wreturn-type -Wunused -Wshadow -funsigned-char 
# C_FLAGS = -O2 -c -Wall -funsigned-char 
# C_FLAGS = -g3 -c -Wall -funsigned-char 
C_FLAGS = -c -DFOR_OS_DOS -Wall -funsigned-char 
LFLAGS =
rm = del


# For DJGPP
.c.o:
	$(CC) $(C_FLAGS) -c $<

.c.exe:
	$(CC) $(C_FLAGS) $<

# all: refgo reftr refc see1 see2
all: refgo reftr refc

refgo: $(OBJS_REFGO)
#	$(CC) $(LFLAGS) version.c $(OBJS_REFGO) -o refgo
#	$(CC) $(LFLAGS) version.c @refgo.lnk -o refgo
	$(CC) $(LFLAGS) @refgo.lnk -o refgo
	$(CC_PATH)\strip refgo
	$(CC_PATH)\aout2exe refgo


reftr: $(OBJS_REFTR)
#	$(CC) $(LFLAGS) version.c $(OBJS_REFTR) -o reftr
#	$(CC) $(LFLAGS) version.c @reftr.lnk -o reftr
	$(CC) $(LFLAGS) @reftr.lnk -o reftr
	$(CC_PATH)\strip reftr
	$(CC_PATH)\aout2exe reftr

refc: $(OBJS_REFC)
#	$(CC) $(LFLAGS) version.c $(OBJS_REFC) -o refc
#	$(CC) $(LFLAGS) version.c @refc.lnk -o refc
	$(CC) $(LFLAGS) @refc.lnk -o refc
	$(CC_PATH)\strip refc
	$(CC_PATH)\aout2exe refc

#see1: see1.c
#	$(CC) -o see1 see1.c
#	$(CC_PATH)\strip see1
#	$(CC_PATH)\aout2exe see1

#see2: see2.c
#	$(CC) -o see2 see2.c
#	$(CC_PATH)\strip see2
#	$(CC_PATH)\aout2exe see2

clean: 
# For WinNT
#	$(rm) *.obj
#	$(rm) reftr.exe refgo.exe refc.exe see1.exe see2.exe
# For Linux
	$(rm) *.o
	$(rm) a.out reftr refgo refc see1 see2

